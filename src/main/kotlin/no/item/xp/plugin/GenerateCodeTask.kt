package no.item.xp.plugin

import arrow.core.flatMap
import arrow.core.left
import arrow.core.right
import no.item.xp.plugin.extensions.getFormNode
import no.item.xp.plugin.models.ObjectTypeModel
import no.item.xp.plugin.parser.parseObjectTypeModel
import no.item.xp.plugin.parser.resolveMixinGraph
import no.item.xp.plugin.renderers.renderGlobalComponentMap
import no.item.xp.plugin.renderers.renderGlobalContentTypeMap
import no.item.xp.plugin.renderers.renderGlobalXDataMap
import no.item.xp.plugin.renderers.ts.renderTypeModelAsTypeScript
import no.item.xp.plugin.util.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.OutputFiles
import org.gradle.api.tasks.TaskAction
import org.gradle.work.ChangeType
import org.gradle.work.Incremental
import org.gradle.work.InputChanges
import org.gradle.workers.WorkerExecutor
import java.io.File
import java.nio.file.Path
import java.nio.file.Paths
import javax.inject.Inject
import kotlin.io.path.nameWithoutExtension

open class GenerateCodeTask
  @Inject
  constructor(objects: ObjectFactory, private val workerExecutor: WorkerExecutor) : DefaultTask() {
    @Input
    var singleQuote = false

    @Suppress("ktlint:standard:max-line-length")
    @Input
    var prependText = "// WARNING: This file was automatically generated by \"no.item.xp.codegen\". You may lose your changes if you edit it."

    @Incremental
    @InputFiles
    val inputFiles: ConfigurableFileCollection = objects.fileCollection()

    @OutputFiles
    val outputFiles: ConfigurableFileCollection = objects.fileCollection()

    @OutputDirectory
    val outputDir: RegularFileProperty = objects.fileProperty()

    @TaskAction
    private fun execute(inputChanges: InputChanges) {
      val workQueue = workerExecutor.noIsolation()
      val rootOutputDir = outputDir.get().asFile
      val gradleConfigInclude = project.configurations.findByName("include")
      val appName = project.findProperty("appName") as String?

      val xmlFilesInJars =
        (gradleConfigInclude?.let { getXmlFilesInJars(it) } ?: emptyList())
          // Remove files from jars with same path relative to "resources" as a filesystem-files
          .filter { fileInJar ->
            !inputFiles.files.any { fileInFileSystem ->
              normalizeFilePath(fileInJar.entry.name) == normalizeFilePath(simpleFilePath(fileInFileSystem))
            }
          }

      val mixinFiles =
        inputFiles
          .filter { file -> IS_MIXIN.matches(normalizeFilePath(file)) }
          .toList()
          .map { it.left() }

      val mixinFilesInJars =
        xmlFilesInJars
          .filter { fileInJar -> IS_MIXIN.matches(normalizeFilePath(File(fileInJar.entry.name))) }
          .map { it.right() }

      val mixins = resolveMixinGraph(mixinFilesInJars + mixinFiles)

      // Iterate over and import from jars
      xmlFilesInJars.forEach { importModelFromJarStream(it, mixins, rootOutputDir) }

      inputChanges.getFileChanges(inputFiles).forEach { change ->
        val targetFile = getTargetFile(change.file, rootOutputDir)

        if (change.changeType == ChangeType.REMOVED && targetFile.delete()) {
          logger.lifecycle("Removed ${targetFile.absolutePath}")
        } else {
          workQueue.submit(GenerateTypeScriptWorkAction::class.java) {
            it.getXmlFile().set(change.file)
            it.getTargetFile().set(targetFile)
            it.getMixins().value(mixins)
            it.getSingleQuote().value(singleQuote)
            it.getPrependText().value(prependText)
          }
        }
      }

      createContentTypeIndexFile(rootOutputDir, appName)

      createComponentIndexFile(rootOutputDir, appName, "parts", xmlFilesInJars, "XpPartMap")
      createComponentIndexFile(rootOutputDir, appName, "layouts", xmlFilesInJars, "XpLayoutMap")
      createComponentIndexFile(rootOutputDir, appName, "pages", xmlFilesInJars, "XpPageMap")
      createComponentIndexFile(rootOutputDir, appName, "mixins", xmlFilesInJars)

      createXDataIndexFile(rootOutputDir, appName, xmlFilesInJars)
    }

    private fun importModelFromJarStream(
      fileInJar: XmlFileInJar,
      mixins: List<ObjectTypeModel>,
      rootOutputDir: File,
    ) {
      return parseXml(fileInJar.jarFile.getInputStream(fileInJar.entry))
        .flatMap { it.getFormNode() }
        .fold(
          {
            ObjectTypeModel(Paths.get(fileInJar.entry.name).fileName.nameWithoutExtension, emptyList()).right()
          },
          {
            parseObjectTypeModel(it, Paths.get(fileInJar.entry.name).fileName.nameWithoutExtension, mixins)
          },
        ).fold(
          { left ->
            logger.error("ERROR in: ${fileInJar.entry.name}")
            logger.error(left.message)
          },
          { right ->
            val fileContent = renderTypeModelAsTypeScript(right)

            var targetFilePath = Paths.get(rootOutputDir.absolutePath, fileInJar.entry.name)
            targetFilePath = Paths.get(targetFilePath.parent.toString(), "index.d.ts")
            logger.lifecycle("Updated file: ${targetFilePath.toUri()}")
            val targetFile = File(targetFilePath.toUri())
            targetFile.parentFile.mkdirs()
            targetFile.createNewFile()
            targetFile.writeText(fileContent, Charsets.UTF_8)
          },
        )
    }

    private fun createContentTypeIndexFile(
      rootOutputDir: File,
      appName: String?,
    ) {
      val files =
        inputFiles.files.filter {
          it.absolutePath.contains(
            concatFileName("resources", "site", "content-types"),
          )
        }.sortedBy { it.name }

      if (files.isNotEmpty()) {
        val fileContent = renderGlobalContentTypeMap(files, appName)
        val targetFile = File(rootOutputDir.absolutePath + "/site/content-types/index.d.ts")
        targetFile.parentFile.mkdirs()
        targetFile.createNewFile()
        targetFile.writeText(prependText + "\n" + fileContent, Charsets.UTF_8)
        logger.lifecycle("Updated file: ${Path.of(targetFile.toURI()).toUri()}")
      }
    }

    private fun createComponentIndexFile(
      rootOutputDir: File,
      appName: String?,
      componentTypeName: String,
      xmlFilesInJars: List<XmlFileInJar>,
      interfaceName: String? = null,
    ) {
      val xmlFiles =
        inputFiles.files
          .filter { it.absolutePath.contains(concatFileName("resources", "site", componentTypeName)) }
          .map { it.nameWithoutExtension }

      val filesInJar =
        xmlFilesInJars
          .filter { it.entry.name.contains(concatFileName("site", componentTypeName)) }
          .map { File(it.entry.name).nameWithoutExtension }

      val files = (xmlFiles + filesInJar).sorted().distinct()

      if (files.isNotEmpty()) {
        val fileContent = renderGlobalComponentMap(files, appName, interfaceName)
        val targetFile = File(concatFileName(rootOutputDir.absolutePath, "site", componentTypeName, "index.d.ts"))
        targetFile.parentFile.mkdirs()
        targetFile.createNewFile()
        targetFile.writeText(prependText + "\n" + fileContent, Charsets.UTF_8)
        logger.lifecycle("Updated file: ${Path.of(targetFile.toURI()).toUri()}")
      }
    }

    private fun createXDataIndexFile(
      rootOutputDir: File,
      appName: String?,
      xmlFilesInJars: List<XmlFileInJar>,
    ) {
      val xmlFiles =
        inputFiles.files
          .filter { it.absolutePath.contains("x-data") }
          .map { it.nameWithoutExtension }

      val filesInJar =
        xmlFilesInJars
          .filter { it.entry.name.contains("x-data") }
          .map { File(it.entry.name).nameWithoutExtension }

      val files = (xmlFiles + filesInJar).sorted().distinct()

      if (files.isNotEmpty()) {
        val fileContent = renderGlobalXDataMap(files, appName)
        val targetFile = File(rootOutputDir.absolutePath + "/site/x-data/index.d.ts")
        targetFile.parentFile.mkdirs()
        targetFile.createNewFile()
        targetFile.writeText(prependText + "\n" + fileContent, Charsets.UTF_8)
        logger.lifecycle("Updated file: ${Path.of(targetFile.toURI()).toUri()}")
      }
    }
  }
